---
title: "SNP clinality"
date: "`r date()`"
---

```{r setup, include=FALSE}
library(pander)
options(scipen=3)
fig.dim <- 5
knitr::opts_chunk$set(fig.height=fig.dim,fig.width=2*fig.dim,fig.align='center')
# locations and labels
tortdir <- gsub("tortoisescape.*","tortoisescape",getwd())
coord.obj <- load(file.path(tortdir,"tort_272_info","geog_coords.RData"))
coords <- get(coord.obj)
tort.ids <- row.names(coords)
```

```{r snp_info, include=FALSE}
datadir <- "."
countfile <- file.path(datadir,"272torts_snp1e6_minmapq20minq30_map2kenro.counts.gz")
# maf <- read.table(file.path(datadir,"272torts_snp1e6_minmapq20minq30_map2kenro.mafs.gz"),header=TRUE)
pos <- read.table(file.path(datadir,"272torts_snp1e6_minmapq20minq30_map2kenro.pos.gz"),header=TRUE)
# scaffolds
minscaf <- 1e4  # minimum number of snps per scaffold
scaf.counts <- table( pos$chr )
long.scafs <- names(scaf.counts)[scaf.counts>=minscaf]
# apply filters
mindepth <- 150 # minimum totalDepth
maxdepth <- 350 # maximum totalDepth
goodones <- ( ( pos$totDepth >= mindepth ) & ( pos$totDepth <= maxdepth ) )
# minind <- 250   # minimum nInd -- RESULTS IN NO SNPs
# goodones <- goodones & ( maf$nInd >= minind )
goodones <- goodones & ( pos$chr %in% long.scafs )
```

```{r count_connection, include=FALSE}
countsuffix <- ".pc1counts.5bin"  # .5bin means binary, five columns
pccountfile <- gsub(".counts.gz",countsuffix,countfile)
pccountheaderfile <- paste0(pccountfile,".header")
pc.header <- scan(pccountheaderfile,what='char')
pc.con <- pipe(paste("cat",pccountfile), open="rb")
read_chunk <- function (blocksize) {
    # do this multiple times to read in chunks
    pc.counts <- readBin(pc.con,what="numeric",n=length(pc.header)*blocksize)
    dim(pc.counts) <- c(length(pc.header),length(pc.counts)/length(pc.header))
    pc.counts <- t(pc.counts)
    colnames(pc.counts) <- pc.header
    return(pc.counts)
}
umat <- read_chunk(nrow(pos))
close(pc.con)
```

# Data

We are only looking at scaffolds with at least `r minscaf` SNPs per scaffold,
and SNPs with total depth between `r mindepth` and `r maxdepth`;
this is a proportion `r mean(goodones)` of the SNPs.


# Computation

We want to compute the correlation and covariance of each site with a vector, $v$ (say, PC1).
If at a given site:

- $c(i) =$ major allele count in indiv $i$
- $n(i) =$ sample size, i.e. coverage of indiv $i$
- $p(i) =$ $c(i)/n(i)$
- $v(i) =$ vector of weights

then we need these things:

- $A = \sum_i p(i)$
- $B = \sum_i p(i) * v(i)$
- $N = #\{ i : n(i) > 0 \}$
- $C = \sum_{i : p(i)>0} v(i)$
- $D = \sum_{i : p(i)>0} v(i)^2$

Then, we estimate the covariance by
$$  ( B - A * C / N ) / N $$
and the correlation by
$$
  ( \text{covariance} ) / \sqrt( ( ( A - A^2 / N ) / N ) * ( ( D - C^2 / N ) / N ) )
  = ( B * N - A * C ) / \sqrt( ( A * N - A^2 ) * ( D * N - C^2 ) )
$$

The five columns of `r pccountfile` are $A$, $B$, $C$, $D$, and $N$, respectively.

```{r convert_counts, include=FALSE}
# A is : sum_freq  
# B is : freq_prod 
# N is : num_nonzero 
pc.num <- 1
pcs <- read.csv(file.path(tortdir,"tort_272_info","pcs.csv"),header=TRUE,stringsAsFactors=FALSE)
pcvec <- pcs[[paste0("PC",pc.num)]]
sum.pcvec <- mean(pcvec)
var.pcvec <- var(pcvec)
snp.freq <- umat[,"sum_freq"] / umat[,"num_nonzero"]
pc.cov <- ( umat[,"freq_prod"] / umat[,"num_nonzero"] - umat[,"sum_freq"] * sum.pcvec / umat[,"num_nonzero"] ) / umat[,"num_nonzero"]
snp.var <- (umat[,"sum_freq"] - (umat[,"sum_freq"]^2) / umat[,"num_nonzero"] ) / umat[,"num_nonzero"]
pc.cor <- pc.cov / sqrt( snp.var * var.pcvec )
```

