```{r setup_packages, include=FALSE}
####
#
# Before running this, have pre-loaded:
#
#   alt.file : name of alternative (e.g. "pref_alt" or "alt_1")
#
####
base.dir <- gsub("tortoisescape/inference/.*","tortoisescape",getwd())
source(file.path(base.dir,"inference","resistance-fns.R"))
require(parallel)
require(colorspace)
require(raster)
require(xtable)
require(fields)  # for Tps (thin-plate spline, below)
fig.dim <- 5
opts_chunk$set(fig.width=2*fig.dim,fig.height=fig.dim,fig.align='center')
```
```{r setup, include=FALSE, cache=TRUE}
# load stuff
config <- read.json.config("config.json")
for (x in config$setup_files) { load(x) }
result.files <- list.files(pattern="inference-.*RData",full.names=TRUE)
last.result <- result.files[ rev(order( file.info(result.files)$mtime )) ][1]
load(last.result)
ref.inds <- trust.optim$ref.inds
params <- trust.optim$argument
G@x <- update.G(params[-1])
# reference points
ref.pt.file <- file.path(base.dir,"geolayers/reference_points/all_ref_points.RData")
ref.pt.obj  <- load(ref.pt.file)
ref.points <- get(ref.pt.obj)
ref.locs <- unlist(get.neighborhoods( 1e-3, ref.points, nonmissing, nalayer ))
ref.neighborhoods <- get.neighborhoods( 15e3, ref.points, nonmissing, nalayer )
```
```{r setup_plots, include=FALSE}
# layers for plotting
habitat <- raster(file.path(base.dir,"geolayers/nussear/habitat-model/nussear.grd"))
dem <- raster(file.path(base.dir,"geolayers/nussear/habitat-model/dem_30.grd"))
# default extent of plotted maps
xlims <- c(327250,877200)
ylims <- c(3608100,4191500)
# plotting helper
ph <- plot.ht.fn(nonmissing=nonmissing,layer=nalayer,sample.loc.file=ref.pt.file)
truncate <- function(x,lims) { pmin(lims[2],pmax(lims[1],x)) }
pt.legend <- function (x,npts=8) {
    # put on points and say what the point sizes mean
    points( ref.points[alt.good.refs], cex=2*abs(scale(x[alt.good.refs])), col=ifelse(x[alt.good.refs]>0,"red","blue") )
    scaled <- scale(x[alt.good.refs])
    zvals <- pretty( attr(scaled,"scaled:center")+c(-1,1)*attr(scaled,"scaled:scale"), n=npts )
    vals <- (zvals - attr(scaled,"scaled:center"))/attr(scaled,"scaled:scale")
    xvals <- rep(8e5,length(zvals))
    yvals <- seq(3.7e6,3.9e6,length.out=length(zvals))
    points( xvals, yvals, cex=2*abs(vals), col=ifelse(vals>0,"red","blue") )
    text( xvals + .2e5, yvals, labels=sprintf("%0.1e",zvals), pos=4 )
}
interp.values <- function (x,refs) {
    # interpolate values seen at ref.points[refs] to everywhere else
    tps <- fastTps( coordinates(ref.points)[refs,], x[refs], lambda=1e-8, theta=2e5 )
    return( mask(interpolate(nalayer,tps),nalayer) )
}
# and the alternative
alt <- crop( extend( raster(file.path(base.dir,"geolayers/alternatives",paste(alt.file,"_poly.tif",sep=''))), nalayer ), nalayer )
stopifnot(compareRaster(alt,nalayer))
orig.chunks <- lapply( unique(values(alt)), function (k) { match(which(values(alt)==k&!is.na(values(nalayer))),nonmissing) } )
chunk.clumped <- clump( mask(nalayer,alt,inverse=TRUE), directions=4 )
chunk.clump.table <- table(values(chunk.clumped))
alt.chunks <- c( orig.chunks, list( match( which( values(chunk.clumped)!=as.numeric(names(chunk.clump.table))[which.max(chunk.clump.table)] ), nonmissing ) ) )
alt.chunks <- alt.chunks[ sapply(alt.chunks,length) > 0 ]
all.chunks <- unique(unlist(alt.chunks))
# check remainder is connected
tmp <- nalayer
tmp[nonmissing[unlist(alt.chunks)]] <- NA
stopifnot(length(table(values(tmp)))==1)
# helper function to deal with nonconnectedness
chunk.hts <- function (k,plot.points=rep(TRUE,length(ref.neighborhoods))) {
    chunk <- match( which(values(alt) %in% k), nonmissing )
    chunk <- chunk[!is.na(chunk)]
    nalayer[nonmissing[chunk]] <- NA
    unblocked <- clump( nalayer, directions=4 )
    unblocked.tab <- table(values(unblocked))
    bigone <- as.numeric(names(unblocked.tab))[which.max(unblocked.tab)]
    blocked <- match( which(values(unblocked)!=bigone), nonmissing )
    new.hts <- hitting.analytic(ref.neighborhoods[plot.points],G,blocked=unique(c(chunk,blocked)))
    attr(new.hts,"blocked") <- blocked
    return(new.hts)
}
```

Alternative evaluation
======================

This is the model in `r gsub(".*tortoisescape/","",getwd())`,
fitted data from `r basename(last.result)`,
with layers `r paste(layer.names,collapse=", ")`.
The parameters are
```{r params, results='asis'}
xtab <- xtable(cbind(params))
print(xtab,type='html')
```
and the model looks like 
```{r model_plot,echo=FALSE}
gamma <- params[2+(1:length(layer.names))]
stationary.base <- rowSums( layers * gamma[col(layers)] )
stationary.dist <- ( 1 + exp( -stationary.base ) )
layout(t(1:2))
delta <- params[2+length(layer.names)+(1:length(layer.names))]
jump.base <- rowSums( layers * delta[col(layers)] )
G@x <- update.G(params[-1])
ph( (-1)*stationary.base, main="logit stationary distribution" )
ph( jump.base, main="logit relative jump rate" )
# plot.model(params,layer.names,layers,G,update.G,ph,xlim=xlims,ylim=ylims)
```


We will use these reference points:
```{r ref_pts, fig.width=fig.dim,echo=FALSE}
plot(habitat,alpha=0.5,col=rev(terrain.colors(250)),legend=FALSE,xlim=xlims,ylim=ylims)
contour(dem,add=TRUE,col="slategrey")
points(ref.points,pch=20,col='red')
# to-do: add state lines, stippling on E side of colorado...
```

Inaccessible locations?
=======================

Under this model, some areas of the range may be inaccessible.
The biggest hitting time we have estimated from divergence is $3.3\times 10^5$,
so we'll treat anything that has mean hitting time larger than $10^6$ as *inacessible*.
To figure out where these are, we first compute hitting times between each of the reference points,
```{r get_hts, echo=FALSE, cache=TRUE, dependson="setup"}
hts <- hitting.analytic(ref.neighborhoods,G)
```
then, identify the reference points whose median hitting time to the other points is larger than $10^6$.
```{r inaccessible_refs}
accessible <- function (hts, ref.locs, cutoff=1e6) { return( apply(hts[ref.locs,],2,median) < cutoff ) }
accessible.refs <- accessible(hts,ref.locs)
```

Furthermore there are reference points that are accessible, but *isolated*:
a walk started there will take more than $10^6$ generations on average
to hit another accessible point.
```{r isolated_refs, echo=FALSE}
isolated <- function (hts,ref.locs,accessible.refs,cutoff=1e6) { return( rowMeans(hts[ref.locs,accessible.refs]) > cutoff ) }
isolated.refs <- isolated(hts,ref.locs,accessible.refs)
```

Here is a plot of $log_{10}$ values of the mean hitting times
from each point on the landscape to the *accessible* reference points,
and on the right those locations where this mean is greater than $10^6$;
the inaccessible reference locations are marked with red circles,
and isolated locations are marked with blue circles (if any):
```{r mean_hts, echo=FALSE}
z <- log10(1+rowMeans(hts[,accessible.refs]))
layout(t(1:2))
ph(z,zlim=c(0,max(10,max(z,na.rm=TRUE))),main="log10 mean hitting times")
if (any(!accessible.refs)) { points(ref.points[!accessible.refs],cex=2,pch=21,col='red',lwd=2) }
if (any(isolated.refs)) { points(ref.points[isolated.refs],cex=1.5,pch=21,col='blue',lwd=2) }
ph( z<6,col=c('red','white'),legend=FALSE)
if (any(isolated.refs)) { points(ref.points[isolated.refs],cex=1.5,pch=21,col='blue',lwd=2) }
```


With these parameters, there are `r sum(!accessible.refs)` inaccessible reference locations and `r sum(isolated.refs)` isolated reference locations.
We omit both inaccessible and isolated locations from the rest of the analysis.
```{r good_refs, echo=FALSE}
good.refs <- ( accessible.refs & ! isolated.refs )
```


The alternative
===============

Here is the alternative we are considering, and the 
`r length(
  chunk.labels <- setdiff(unique(values(alt)),NA)
)` 
chunks it is divided into:
```{r show_alt,echo=FALSE}
layout(t(1:2))
plot(habitat,alpha=0.5,col=rev(terrain.colors(250)),legend=FALSE,xlim=xlims,ylim=ylims)
contour(dem,col="slategrey",add=TRUE)
plot(alt,add=TRUE,legend=FALSE,col="red")
# and without the background
contour(dem,col="slategrey",xlim=xlims,ylim=ylims)
plot(alt,add=TRUE,legend=FALSE,col=rainbow(length(unique(values(alt)))))
```


Effects of removing the entire alternative
==========================================

First we'll look at hitting times after removing the entire alternative.
```{r alt_hts, include=FALSE, cache=TRUE, dependson="setup"}
this.chunk <- chunk.labels
alt.hts <- chunk.hts(this.chunk)
```
```{r newly_isolated,echo=FALSE}
in.chunk <- function (k,locs) {
    # find the bits isolated by chunks
    chunk.clump <- clump( mask( nalayer, mask( alt, (alt %in% k), maskvalue=FALSE ), inverse=TRUE), directions=4 )
    clump.table <- table(values(chunk.clump))
    bigone <- as.numeric( names(clump.table)[which.max(clump.table)] )
    return( is.na(values(chunk.clump)[nonmissing[locs]]) | ( values(chunk.clump)[nonmissing[locs]] != bigone ) )
}
in.chunk.refs <- in.chunk( this.chunk, ref.locs )
alt.accessible.refs <- accessible(alt.hts, ref.locs )
newly.inaccessible.refs <- ( accessible.refs & ! alt.accessible.refs )
alt.isolated.refs <- isolated(alt.hts, ref.locs, alt.accessible.refs )
newly.isolated.refs <- ( alt.isolated.refs & ! isolated.refs )
alt.good.refs <- ( ( ! in.chunk.refs ) & alt.accessible.refs & ( ! alt.isolated.refs ) ) 
```
This has made 
`r sum(!alt.good.refs)` 
additional reference points inaccessible and/or isolated.
Here are a few hitting times, and how they change after removing the alternative:
*(note: should mask inaccessible/isolated regions in plots?)*
```{r some_hts, fig.width=3*fig.dim, echo=FALSE, cache=TRUE, dependson="alt_hts"}
# representative points to plot
plot.points <- which(alt.good.refs)[which.nonoverlapping( get.neighborhoods( 80e3, ref.points[alt.good.refs], nonmissing, nalayer ) )]
zlims <- quantile( hts[ref.locs[alt.good.refs],alt.good.refs], c(0,.95) )
diff.zlims <- quantile( (alt.hts-hts)[ref.locs[alt.good.refs],alt.good.refs], c(.05,.95) )
ratio.zlims <- c(-1,1)*max(abs(quantile( ((alt.hts-hts)/(1+hts))[ref.locs[alt.good.refs],alt.good.refs], c(.01,.99) )))
layout(t(1:3))
for (k in plot.points) {
    ph( pmin(zlims[2],alt.hts[,k]), zlim=zlims, do.lims=FALSE, main="new hitting time" )
    plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
    points( ref.points[k], pch=8, cex=2 )
    ph( truncate((alt.hts[,k]-hts[,k]),diff.zlims), zlim=diff.zlims, do.lims=FALSE, main="difference" )
    plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
    points( ref.points[k], pch=8, cex=2 )
    ph( truncate((alt.hts[,k]-hts[,k])/(1+hts[,k]),ratio.zlims), zlim=ratio.zlims, do.lims=FALSE, main="ratio" )
    plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
    points( ref.points[k], pch=8, cex=2 )
    if ( interactive() && length(locator(1))==0) { break }
}
```


Removing these affects hitting times to and from each reference point;
here is the mean difference in resistance distance for each point averaged across all reference locations,
and then the maximum:
```{r relative_effects, echo=FALSE}
sym <- function (x) { (x+t(x))/2 }
mean.tdiffs <- rowMeans(sym((alt.hts-hts)[ref.locs,])[,alt.good.refs])
max.tdiffs <- apply(sym((alt.hts-hts)[ref.locs,])[,alt.good.refs],1,max)
diff.cols <- diverge_hcl(128, h=c(225,0), c=100, l=c(60,95), power=0.65)
layout(t(1:2))
zlims <- c(-1,1)*max(abs(tdiffs))
plot( interp.values(mean.tdiffs,alt.good.refs), main="mean difference", col=diff.cols, zlim=zlims )
plot( interp.values(max.tdiffs,alt.good.refs), main="maximum difference", col=diff.cols, zlim=zlims )
```


More plots of pretty much the same thing
----------------------------------------

This is an interpolated map of the mean differences in hitting times:
```{r relative_effects, echo=FALSE}
which.max.diffs  <- apply((alt.hts-hts)[,alt.good.refs],1,which.max)
to.diffs <- colMeans((alt.hts-hts)[ref.locs[alt.good.refs],])
from.diffs <- rowMeans((alt.hts-hts)[ref.locs,alt.good.refs])
diff.cols <- diverge_hcl(128, h=c(225,0), c=100, l=c(60,95), power=0.65)
layout(t(1:2))
zlims <- c(-1,1)*max(abs((alt.hts-hts)[ref.locs[alt.good.refs],alt.good.refs]))
plot( interp.values(to.diffs,alt.good.refs), main="mean difference to", col=diff.cols, zlim=zlims )
plot( interp.values(from.diffs,alt.good.refs), main="mean difference from", col=diff.cols, zlim=zlims )
# ph( which.max.diffs, do.lims=FALSE,main="mean difference to", legend=FALSE)
# pt.legend( to.diffs )
# ph( which.max.diffs, do.lims=FALSE,main="mean difference from", legend=FALSE)
# pt.legend( from.diffs )
```


This is the same thing, but dividing by hitting time
```{r ratio_effects, echo=FALSE}
to.ratio <- colMeans( (alt.hts-hts)[ref.locs[alt.good.refs],] / ( 1+hts[ref.locs[alt.good.refs],] ) )
from.ratio <- rowMeans( (alt.hts-hts)[ref.locs,alt.good.refs] / ( 1+hts[ref.locs,alt.good.refs] ) )
zlims <- c(-1,1)*max(pmin(5,abs(c(to.ratio,from.ratio))))
layout(t(1:2))
plot( interp.values(to.ratio,alt.good.refs), main="mean relative difference to", col=diff.cols, zlim=zlims )
contour( !is.na(alt), col=adjustcolor('black',.2), add=TRUE, legend=FALSE )
plot( interp.values(from.ratio,alt.good.refs), main="mean relative difference from", col=diff.cols, zlim=zlims )
contour( !is.na(alt), col=adjustcolor('black',.2), add=TRUE, legend=FALSE )
```


Here are plots of almost the same thing, but for all locations, only "to":
on the left is the mean across reference locations, the right is the maximum:
```{r mean_diff_plot, echo=FALSE}
layout(t(1:2))
# mean difference
mean.diffs <- rowMeans((alt.hts-hts)[,alt.good.refs])
zlims <- range(0,mean.diffs[ref.locs[alt.good.refs]])
ph( truncate(mean.diffs,zlims), do.lims=FALSE, main="mean difference" )
plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
# max difference
max.diffs <- apply((alt.hts-hts)[,alt.good.refs],1,max)
zlims <- range(0,max.diffs[ref.locs[alt.good.refs]])
ph( truncate(max.diffs,zlims), do.lims=FALSE, main="max difference" )
plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
```
Here is the same thing, except showing relative change (difference divided by one plus hitting time):
```{r max_diff_plot, echo=FALSE}
layout(t(1:2))
# mean ratio
mean.ratio <- rowMeans(((alt.hts-hts)/(1+hts))[,alt.good.refs])
zlims <- range(0,mean.ratio[ref.locs[alt.good.refs]])
ph( truncate(mean.ratio,zlims), do.lims=FALSE, main="mean ratio" )
plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
# max ratio
max.ratio <- apply(((alt.hts-hts)/(1+hts))[,alt.good.refs],1,max)
zlims <- range(0,max.ratio[ref.locs[alt.good.refs]])
ph( truncate(max.ratio,zlims), do.lims=FALSE, main="max ratio" )
plot( alt, col=adjustcolor('red',.8), add=TRUE, legend=FALSE )
```

Summarizing the impact of the alternative
-----------------------------------------

At least preliminarily, we will look at these summaries of the effect of the alternative on gene flow:
- (**area removed**) number of newly inaccessible or isolated reference locations **not** in the affected area (the remainder do not use these)
- (**worst isolation**) the maximum across reference locations of the mean change in hitting time from other reference locations, with decreases in hitting time counted as zero
- (**total reduction**) the mean change in hitting time between any pair of reference locations, with decreases in hitting time counted as zero
- (**typical relative reduction**) the mean value of the ratio of change in hitting time to hitting time, with decreases in hitting time counted as zero
```{r summary_fun,echo=FALSE}
summary.expr <- quote( 
    { 
        diffmat <- pmax(0,sub.alt.hts-sub.hts)
        dim(diffmat) <- c( sum(alt.good.refs), sum(alt.good.refs) )
        blocked <- attr(alt.hts,"blocked")
        data.frame(
            "this chunk" = paste(sort(this.chunk),collapse=","),
            "cells removed" = sum( !is.na( values(nalayer)[ unique(c(blocked,which(values(alt)%in%this.chunk))) ] ) ),
            "references removed" = sum( newly.inaccessible.refs | newly.isolated.refs ),
            "worst isolation" = max( rowMeans( diffmat ) ),
            "total reduction" = mean( diffmat ),
            "relative reduction" = mean( diffmat/(1+sub.hts) )
    ) } )
sub.alt.hts <- alt.hts[ref.locs[alt.good.refs],alt.good.refs]
sub.hts <- hts[ref.locs[alt.good.refs],alt.good.refs]
eval(summary.expr)
```


Evaluating different subchunks
==============================

This alternative is broken up into `r length(chunk.labels)` pieces;
we can compute the above things separately for each piece.
First, we'll compute the necessary quantities:
```{r subchunk_computation, echo=FALSE}
chunk.info.file <- paste(alt.file,"-subchunks",".RData",sep='')
if (!file.exists(chunk.info.file)) {
    chunk.info.list <- lapply( chunk.labels, function (this.chunk) {
            this.file <- paste(alt.file,"-subchunk-",paste(this.chunk,collapse="_"),".RData",sep='')
            if (!file.exists(this.file)) {
                alt.hts <- chunk.hts(this.chunk)
                in.chunk.refs <- in.chunk( this.chunk, ref.locs )
                alt.accessible.refs <- accessible(alt.hts, ref.locs )
                newly.inaccessible.refs <- ( accessible.refs & ! alt.accessible.refs )
                alt.isolated.refs <- isolated(alt.hts, ref.locs, alt.accessible.refs )
                newly.isolated.refs <- ( alt.isolated.refs & ! isolated.refs )
                alt.good.refs <- ( ( ! in.chunk.refs ) & alt.accessible.refs & ( ! alt.isolated.refs ) ) 
                sub.alt.hts <- alt.hts[ref.locs[alt.good.refs],alt.good.refs]
                sub.hts <- hts[ref.locs[alt.good.refs],alt.good.refs]
                save( this.chunk, 
                        sub.hts,
                        sub.alt.hts, 
                        in.chunk.refs, 
                        alt.accessible.refs, 
                        newly.inaccessible.refs, 
                        alt.isolated.refs, 
                        newly.isolated.refs, 
                        alt.good.refs, 
                   file=this.file )
           } else { 
               this.ls <- load(this.file) 
               if ( ("chunk.label" %in% this.ls) && ! ("this.chunk" %in% this.ls) ) { this.chunk <- chunk.label } # ; save( list=c("this.chunk",setdiff(this.ls,"chunk.label")), file=this.file ) }
           }
           return( list( this.chunk=this.chunk, 
                   sub.alt.hts=sub.alt.hts,
                   sub.hts=sub.hts,
                   in.chunk.refs=in.chunk.refs, 
                   alt.accessible.refs=alt.accessible.refs, 
                   newly.accessible.refs=newly.inaccessible.refs, 
                   alt.isolated.refs=alt.isolated.refs, 
                   newly.isolated.refs=newly.isolated.refs, 
                   alt.good.refs=alt.good.refs 
               ) )
       } )
    save(chunk.info.list,file=chunk.info.file)
} else { load(chunk.info.file) }
chunk.stats <- do.call( rbind, lapply( chunk.info.list, function (chunk.info) {
                eval( summary.expr, envir=list2env(chunk.info) )
            } ) )
```
```{r subchunk_results, results='asis'}
xtab <- xtable(chunk.stats[order(chunk.stats$total.reduction),])
print(xtab,type='html')
```


Wait, which chunk is which, again?
Here are the locations and labels:
```{r which_chunks, fig.width=fig.dim}
chunk.centers.xy <- sapply( chunk.labels, function (k) { colMeans( xyFromCell( alt, which(values(alt)==k) ) ) } )
chunk.centers <- SpatialPoints(coords=t( chunk.centers.xy),proj4string=CRS(proj4string(alt)),bbox=bbox(alt))
chunk.cols <- rainbow(max(chunk.labels))[chunk.labels]
eps <- c(0,4e4)
plot(alt, xlim=c(327250,777200), ylim=c(3608100,4100000), col=rainbow(max(chunk.labels)))
text( chunk.centers, labels=chunk.labels )
points( chunk.centers, pch=21, cex=3, col=chunk.cols )
```
and the effects above:
```{r isolation_stats}
layout(t(1:2))
plot( alt, main="worst isolation" )
points( chunk.centers, pch=21, cex=sqrt(chunk.stats$worst.isolation/10), col=chunk.cols, bg=adjustcolor(chunk.cols,.5) )
plot( alt, main="total reduction")
points( chunk.centers, pch=21, cex=sqrt(chunk.stats$total.reduction/10), col=chunk.cols, bg=adjustcolor(chunk.cols,.5) )
```
